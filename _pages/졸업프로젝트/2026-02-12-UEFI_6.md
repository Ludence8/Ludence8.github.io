---
title: "UEFI DXE ë°”ì´ë„ˆë¦¬ ì·¨ì•½ì  ë¶„ì„ê¸° í”„ë¡œì íŠ¸_6"
tags: [UEFI, Ghidra]
toc: true
math: true
date: 2026-02-12 11:00 +0800
thumbnail: "/image/javaGhidra.png"
---
## í”„ë¡œì íŠ¸ ìµœì¢… ë¶„ë°°
&nbsp;í”„ë¡œì íŠ¸ ìµœì¢… ì¸ì› ë¶„ë°°ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ê²°ì •í–ˆë‹¤.
1. Ring -2 ì·¨ì•½ì  ë¶„ì„ ë° ìŠ¤í¬ë¦½íŠ¸ ì‘ì„±, ìµœì¢… ë¬¸ì„œí™”
2. DXE Dispatcher ì·¨ì•½ì  ë¶„ì„ ë° ìŠ¤í¬ë¦½íŠ¸ ì‘ì„±
3. Ring 0 ì·¨ì•½ì  ë¶„ì„ ë° ìŠ¤í¬ë¦½íŠ¸ ì‘ì„±
4. ì·¨ì•½ì  ì½”ë“œ ìƒì„± ë° í…ŒìŠ¤íŠ¸
5. ìŠ¤í¬ë¦½íŠ¸ ìë™í™” ë° ìµœì¢… ë¬¸ì„œí™”
 
ì´ë ‡ê²Œ ë‚˜ëˆ´ê³  ë‚œ 1ë²ˆ ì—­í• ì„ ë‹´ë‹¹í•˜ê¸°ë¡œ í•˜ì˜€ë‹¤.

## Intellij Ghidra ì„¤ì • ë°©ë²•
&nbsp;ìŠ¤í¬ë¦½íŠ¸ë¥¼ ë‹´ë‹¹í•  ì¡°ì›ë“¤ë¼ë¦¬ëŠ” Ghidraê°€ Javaë¡œ ì“°ì¸ ë§Œí¼ Javaë¡œ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì‘ì„±í•˜ê¸°ë¡œ ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆ´ë‹¤. ì‚¬ì‹¤ Jythonìœ¼ë¡œ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì§œë‹¤ê°€ Javaë¡œ ë„˜ì–´ê°€ëŠ” ë°”ëŒì— ì„¤ì •ì—ì„œ ì‚½ì§ˆì„ ì¡°ê¸ˆ í–ˆë‹¤...
ì„¤ì •ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.
1. Intellij ì„¤ì¹˜ ë° í”„ë¡œì íŠ¸ ìƒì„±
2. íŒŒì¼ -> í”„ë¡œì íŠ¸ êµ¬ì¡° -> ëª¨ë“ˆ
3. \+ í´ë¦­ -> JAR ë˜ëŠ” ë””ë ‰í† ë¦¬
4. ì•„ë˜ ë””ë ‰í† ë¦¬ ë‚´ë¶€ JAR íŒŒì¼ë“¤ì„ ì „ë¶€ ì„í¬íŠ¸í•˜ê¸°
(Mac Homebrew ì„¤ì¹˜ ê¸°ì¤€(opt/homebrew/Cellar/Ghidra/12.02/libexec/Ghidra)ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•œë‹¤.)
(ì•„ë§ˆ ìœˆë„ìš° ì—­ì‹œ ë¹„ìŠ·í•œ ê²½ë¡œì— ìˆì„ ê²ƒìœ¼ë¡œ ìƒê°ëœë‹¤...)
(ë³¸ì¸ì´ ì¼ë‹¨ ë‹¤ ë°›ê³  ë³¸ ë¶€ë¶„ë„ ì—†ì§€ ì•Šì•„ ìˆì–´ ì–´ë–¤ê±´ í•„ìš”í•˜ì§€ ì•Šì„ ìˆ˜ë„ ìˆê³ , ë” í•„ìš”í•œê²Œ ìˆì„ ìˆ˜ë„ ìˆë‹¤.)
    1. Features/Base/lib
    2. Framework/SoftwareModeling/lib
    3. Framework/Generic/lib
    4. Framework/Docking/lib
    5. Framework/Project/lib
    6. Features/Decompiler/lib
    7. Framework/Utility/lib

ìœ„ì™€ ê°™ì´ ì˜ ì§„í–‰í–ˆë‹¤ë©´
![ì œëª©](/image/javaGhidra.png)
ìœ„ ì´ë¯¸ì§€ì™€ ê°™ì´ Ghidra ë¬¸ë²•ì— ìë™ì™„ì„±ì´ ì˜ ì¡íŒë‹¤!

## ê°„ë‹¨í•œ íƒì§€ ìŠ¤í¬ë¦½íŠ¸ ì‘ì„±
```java
@Override
public void run() throws Exception {
    println("=== SMM Indirect Call ê²€ì¦ê¸° (Safety Check íƒì§€) ì‹œì‘ ===");

    InstructionIterator instructions = currentProgram.getListing().getInstructions(true);
    int suspiciousCount = 0;
    int highRiskCount = 0;

    while (instructions.hasNext()) {
        if (monitor.isCancelled()) break;
        Instruction instr = instructions.next();

        // 1. CALL ëª…ë ¹ì–´ ì°¾ê¸°
        if (!instr.getMnemonicString().equalsIgnoreCase("CALL")) continue;

        // 2. ì˜¤í¼ëœë“œ ë¶„ì„ (RAX, RBX ë“± ë ˆì§€ìŠ¤í„° í˜¸ì¶œì¸ì§€?)
        String opString = instr.getDefaultOperandRepresentation(0);

        // "0x..." ê³ ì • ì£¼ì†Œ í˜¸ì¶œì´ë‚˜ "[...]" ë©”ëª¨ë¦¬ ì°¸ì¡°ëŠ” ì¼ë‹¨ íŒ¨ìŠ¤ (ë³µì¡í•˜ë‹ˆê¹Œ)
        // ì˜¤ì§ "CALL RAX", "CALL R12" ê°™ì€ ìˆœìˆ˜ ë ˆì§€ìŠ¤í„° í˜¸ì¶œë§Œ ì§‘ì¤‘ íƒ€ê²©!
        boolean isRegisterCall = !opString.contains("[") && !opString.startsWith("0x");

        if (isRegisterCall) {
            // í˜¸ì¶œì— ì‚¬ìš©ëœ ë ˆì§€ìŠ¤í„° ê°€ì ¸ì˜¤ê¸° (ì˜ˆ: RAX)
            Register callReg = instr.getRegister(0);

            if (callReg != null) {
                //í•µì‹¬: ë’¤ë¡œ 15ì¤„ ê²€ìƒ‰í•´ì„œ CMPë‚˜ TESTê°€ ìˆëŠ”ì§€ í™•ì¸!
                boolean isChecked = hasSafetyCheck(instr, callReg, 15);

                if (!isChecked) {
                    println(String.format("ğŸš¨ [ì´ˆìœ„í—˜/No-Check] ì£¼ì†Œ: %s | ì½”ë“œ: %s | (ê²€ì¦ ë¡œì§ ë°œê²¬ ëª»í•¨)",
                            instr.getAddress(), instr.toString()));
                    highRiskCount++;
                } else {
                    println(String.format("âœ… [ì•ˆì „ ì¶”ì •] ì£¼ì†Œ: %s | ì½”ë“œ: %s | (ê²€ì¦ ë¡œì§ ìˆìŒ)",
                            instr.getAddress(), instr.toString()));
                }
                suspiciousCount++;
            }
        }
    }

    println("==========================================");
    println("ë¶„ì„ ì™„ë£Œ: ì´ " + suspiciousCount + "ê°œ ì¤‘ " + highRiskCount + "ê°œê°€ 'ê²€ì¦ ì—†ëŠ” ìœ„í—˜ í˜¸ì¶œ'ë¡œ ë³´ì…ë‹ˆë‹¤.");
}

// ë’¤ë¡œ ê±¸ì–´ê°€ë©´ì„œ ê²€ì‚¬ ë¡œì§(CMP, TEST) ì°¾ëŠ” í•¨ìˆ˜
private boolean hasSafetyCheck(Instruction startInstr, Register targetReg, int maxSteps) {
    Instruction current = startInstr.getPrevious(); // ë°”ë¡œ ìœ—ì¤„ë¶€í„° ì‹œì‘
    int steps = 0;

    while (current != null && steps < maxSteps) {
        String mnemonic = current.getMnemonicString();

        // 1. ë¹„êµ(CMP)ë‚˜ í…ŒìŠ¤íŠ¸(TEST) ëª…ë ¹ì–´ë¥¼ ì°¾ìŒ
        if (mnemonic.equalsIgnoreCase("CMP") || mnemonic.equalsIgnoreCase("TEST")) {
            // 2. ê·¸ ëª…ë ¹ì–´ê°€ ìš°ë¦¬ê°€ ì˜ì‹¬í•˜ëŠ” ë ˆì§€ìŠ¤í„°(targetReg)ë¥¼ ì“°ëŠ”ì§€ í™•ì¸
            Object[] opObjects = current.getOpObjects(0); // ì²« ë²ˆì§¸ ì˜¤í¼ëœë“œ
            for (Object op : opObjects) {
                if (op instanceof Register && ((Register) op).equals(targetReg)) {
                    return true; // ì•ˆì „ì¥ì¹˜ ë°œê²¬!
                }
            }
        }

        // ë§Œì•½ ë ˆì§€ìŠ¤í„° ê°’ì´ ì—¬ê¸°ì„œ ë®ì–´ì”Œì›Œì¡Œë‹¤ë©´(MOV RAX, ...), ê·¸ ìœ„ëŠ” ë³¼ í•„ìš” ì—†ìŒ (ì¶”ì  ëŠê¹€)
        if (mnemonic.equalsIgnoreCase("MOV") || mnemonic.equalsIgnoreCase("LEA")) {
            Object[] resultObjects = current.getResultObjects();
            for (Object res : resultObjects) {
                if (res instanceof Register && ((Register) res).equals(targetReg)) {
                    return false; // ê°’ì„ ë§‰ ëŒ€ì…í•˜ê³  ë°”ë¡œ í˜¸ì¶œí•¨ -> ìœ„í—˜!
                }
            }
        }

        current = current.getPrevious(); // í•œ ì¤„ ë” ìœ„ë¡œ
        steps++;
    }
    return false; // ëê¹Œì§€ ê²€ì‚¬ ë¡œì§ ëª» ì°¾ìŒ
}
```
ì¼ë‹¨ ê°ì´ë¼ë„ ì¢€ ì¡ì•„ë³´ê¸° ìœ„í•´ ì œë¯¸ë‚˜ì´ì™€ í•¨ê»˜ ìŠ¤í¬ë¦½íŠ¸ë¥¼ í•˜ë‚˜ ì§œë´¤ë‹¤. ì½”ë“œ ì•„ì´ë””ì–´ëŠ” ì¼ë‹¨ P-Code ì—†ì´ ë§¤ìš° ë‹¨ìˆœí•œ í˜•íƒœë¡œ, instruction ì¤‘ CALLì„, ê·¸ ì¤‘ì—ì„œë„ ë ˆì§€ìŠ¤í„°ë¥¼ í˜¸ì¶œí•˜ëŠ” ë¶€ë¶„ì„ ë°œê²¬í•œë‹¤ë©´ í•´ë‹¹ instruction ìœ„ë¡œ 15ê°œ instructionì„ í™•ì¸í•´ì„œ, ê·¸ ì¤‘ TESTë‚˜ CMPê°€ ìˆëŠ”ì§€ í™•ì¸ì„ í•˜ê³  ê²€ì‚¬ë¥¼ í•˜ëŠ” ë¶€ë¶„ì´ ì—†ë‹¤ë©´ ì•ˆì „í•˜ì§€ ì•Šë‹¤ê³  íŒë‹¨ì„ í•˜ê±°ë‚˜, ë˜ëŠ” ê·¸ ì‚¬ì´ì— í•´ë‹¹ ë ˆì§€ìŠ¤í„° ê°’ì´ ë®ì–´ì”Œì›Œì§€ëŠ”ì§€ ì—¬ë¶€ë¥¼ í™•ì¸í•œë‹¤. 
&nbsp;ëŒ€ìƒì€ [edk2-stable202102](https://github.com/tianocore/edk2/tree/edk2-stable202102)ë²„ì „ì„ ë¹Œë“œí•œ ë’¤ OVMF.md íŒŒì¼ì„ ë§Œë“¤ì—ˆê³ , ê·¸ ì¤‘ì—ì„œ VariableSmm DXE ë“œë¼ì´ë²„ë¥¼ UEFIToolë¡œ ì¶”ì¶œí•œ ë‹¤ìŒ Ghidraë¡œ ì¼œì„œ í•´ë‹¹ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì‘ì„±í•˜ì˜€ë‹¤.

## ê·¸ëŸ°ë°..
**ì—¬ê¸°ë¶€í„°ëŠ” ì œ ê°œì¸ì ì¸ ìƒê°ê³¼ ì¶”ì¸¡ë“¤ì„ ì‘ì„±í–ˆìŠµë‹ˆë‹¤! ë˜í•œ ë§Œì•½ ì¶”ì¸¡ì´ ì˜ëª»ë˜ì—ˆë‹¤ê³  ìƒê°í•˜ì‹œë©´ ì–¸ì œë“  ì´ì•¼ê¸°í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤. ë˜í•œ ìë£Œë¥¼ ì°¾ê³  ì¶”ì¸¡í•˜ëŠ” ê³¼ì •ì—ì„œ ìˆ˜ì‹œë¡œ ê¸€ì„ ìˆ˜ì •í•´ì„œ ë‚´ìš©ì´ ì¤‘êµ¬ë‚œë°©ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤...ã… ã… **

&nbsp;ì¼ë‹¨ ì•„ë˜ ë‚´ìš©ì„ ì„¤ëª…í•˜ê¸° ì „ì— SMM Calloutì´ ë­”ì§€, VariableSmmì´ ì–´ë–¤ ì—­í• ì„ ìˆ˜í–‰í•˜ëŠ”ì§€ ì§šê³  ë„˜ì–´ê°€ë³´ì. SMM Callout ì·¨ì•½ì ì€ SMM ì½”ë“œê°€ SMRAM ë°–ì˜ ì˜ì—­ì— ìˆëŠ” ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë©° ë°œìƒí•˜ëŠ” ì·¨ì•½ì ì´ë‹¤. í•´ì»¤ê°€ ì•…ì˜ì  payloadë¥¼ ë©”ëª¨ë¦¬ì— ì‹¬ê³ , SMMì—ê²Œ í•´ë‹¹ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë„ë¡ í–ˆì„ ë•Œ, SMMì´ í•´ë‹¹ ì½”ë“œë¥¼ ê²€ì¦ ì—†ì´ ì‹¤í–‰í•œë‹¤ë©´, ê³µê²©ìëŠ” SMMì˜ ë†’ì€ ê¶Œí•œì„ ì´ìš©í•´ ì‹œìŠ¤í…œì„ ì™„ì „íˆ ì¥ì•…í•  ìˆ˜ ìˆë‹¤. VariableSmmì€ UEFI íŒì›¨ì–´ì—ì„œ ì‹œìŠ¤í…œ ë³€ìˆ˜ ê´€ë¦¬ë¥¼ ë‹´ë‹¹í•˜ëŠ” ë“œë¼ì´ë²„ë¡œ, SMM ëª¨ë“œì—ì„œ ì‹¤í–‰ë˜ë©° ì‹œìŠ¤í…œ ë³€ìˆ˜ì— ëŒ€í•œ ì ‘ê·¼ê³¼ ê´€ë¦¬ë¥¼ ìˆ˜í–‰í•œë‹¤. ì´ ë“œë¼ì´ë²„ê°€ SMM Callout ì·¨ì•½ì ì— ë…¸ì¶œëœë‹¤ë©´, ê³µê²©ìëŠ” VariableSmmì´ í˜¸ì¶œí•˜ëŠ” ì™¸ë¶€ ì½”ë“œë¥¼ ì•…ìš©í•˜ì—¬ SMM ê¶Œí•œìœ¼ë¡œ ì•…ì„± ì½”ë“œë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤.
&nbsp;Ghidra ìŠ¤í¬ë¦½íŠ¸ì™€ ì¹œí•´ì§€ê¸° ìœ„í•´ ì¼ë‹¨ ì œë¯¸ë‚˜ì´ì™€ í•¨ê»˜ ì§  ìœ„ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì‹¤í–‰í•˜ì˜€ë‹¤.
![ì œëª©](/image/scriptConsole.png)
ìŠ¤í¬ë¦½íŠ¸ë¥¼ ëŒë¦° ë’¤ì˜ ê²°ê³¼ë‹¤. ê²°ê³¼ ì¤‘ ìœ ë… CALL R13ì—ì„œ ë°˜ë³µì ìœ¼ë¡œ ìœ„í—˜ ë¡œì§ì´ ì¡íŒ ê²ƒì´ ì´ìƒí•˜ê²Œ ë³´ì—¬ì„œ í•´ë‹¹ ì£¼ì†Œë¥¼ íƒ€ê³  ë“¤ì–´ê°€ë³´ì•˜ë‹¤.
![ì œëª©](/image/resultConsole.png)
ì—¬ê¸°ì„œ CALL R13 ì½”ë“œì—ì„œ 8ì¹¸ ìœ„ë¡œ ê°€ë³´ë©´ MOV R13, qword ptr \[param_1 + 0x28\] ì„ í†µí•´ R13ì— ì²« ë²ˆì§¸ ì¸ìì˜ ì¼ë¶€ ê°’ì´ ë‹´ê¸°ê³ , ì´í›„ë¡œ TESTë‚˜ CMP ë“± ë³„ë„ ë¡œì§ ì—†ì´ ê·¸ëŒ€ë¡œ CALLì´ ì´ë¤„ì§„ ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤! ì¼ë‹¨ ìš°ë¦¬ëŠ” ì˜¤í”ˆì†ŒìŠ¤ë¡œ ê³µê°œë˜ì–´ ìˆëŠ” edk2ë¥¼ ë¶„ì„í•˜ê³  ìˆìœ¼ë¯€ë¡œ ghidraê°€ ë§Œë“¤ì–´ì¤€ ë””ì»´íŒŒì¼ ì½”ë“œë¥¼ ê°€ì§€ê³  ì œë¯¸ë‚˜ì´ì™€ í•¨ê»˜ í•´ë‹¹ ì½”ë“œê°€ edk2ì˜ ì–´ë–¤ ì½”ë“œì¸ì§€ ì°¾ì•„ë³´ì•˜ê³ , í•´ë‹¹ ì½”ë“œê°€ ì•”í˜¸í™” ì½”ë“œì¸ CryptoPkg/Library/OpensslLib/openssl/crypto/modes/gcm128.cë¼ ì¶”ì¸¡í•˜ì˜€ë‹¤.
```C
int CRYPTO_gcm128_encrypt(GCM128_CONTEXT *ctx,
                          const unsigned char *in, unsigned char *out,
                          size_t len)
{
    const union {
        long one;
        char little;
    } is_endian = { 1 };
    unsigned int n, ctr, mres;
    size_t i;
    u64 mlen = ctx->len.u[1];
    block128_f block = ctx->block; //ì—¬ê¸°!!
    void *key = ctx->key;
    ...
        (*block) (ctx->Yi.c, ctx->EKi.c, key); //í‘!!!!
    ...
}
```
í•´ë‹¹ ë¶€ë¶„ì´ ë¬¸ì œì˜ ë¶€ë¶„ìœ¼ë¡œ, block128_f block = ctx->block; ì½”ë“œì—ì„œ block ë³€ìˆ˜ì— ctx->block ê°’ì„ ë³„ë„ ê²€ì‚¬ ë¡œì§ ì—†ì´ ê°€ì ¸ì˜¤ê³ , ì´í›„ ë³„ë„ ê²€ì‚¬ ë¡œì§ ì—†ì´ (*block) (ctx->Yi.c, ctx->EKi.c, key);ë¥¼ í†µí•´ ì‹¤í–‰ì„ í•˜ê²Œ ëœë‹¤ê³  ì¶”ì¸¡í•˜ì˜€ë‹¤.
&nbsp;í•´ë‹¹ ì½”ë“œê°€ VariableSmmì— ì™œ ë“¤ì–´ìˆëŠ”ì§€ ìƒê°í•´ë³´ì•˜ëŠ”ë°, ìš°ì„  OpenSSLì€ ì˜¤í”ˆì†ŒìŠ¤ ë³´ì•ˆ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ, ë‹¤ì–‘í•œ ì•”í˜¸í™” ì•Œê³ ë¦¬ì¦˜, í”„ë¡œí† ì½œ ë“±ì„ ì œê³µí•˜ê³  ìˆë‹¤. ê·¸ë¦¬ê³  VariableSmmì€ ì‹œìŠ¤í…œ ë³€ìˆ˜ë¥¼ ê´€ë¦¬í•˜ëŠ” ë“œë¼ì´ë²„ë¡œì¨, ë³´ì•ˆê³¼ ë°€ì ‘í•˜ê²Œ ê´€ë ¨ëœ ë³€ìˆ˜, ì˜ˆë¥¼ ë“¤ì–´ Secure Boot í‚¤ ë“±ì„ ë‹¤ë£¨ê²Œ ëœë‹¤. ì´ ê³¼ì •ì—ì„œ ì•ˆì „í•œ ë°ì´í„° ì €ì¥ì„ ìœ„í•´ ì•”í˜¸í™”ë¥¼ ì‚¬ìš©í•œë‹¤ê³  ìƒê°í•˜ì˜€ë‹¤. ì´ ë•Œ ìœ„ OpenSSL ë¼ì´ë¸ŒëŸ¬ë¦¬ ì½”ë“œë¥¼ ì¼ë°˜ì ì¸ ìƒí™©ì—ì„œ ì‚¬ìš©í•œë‹¤ë©´ ìƒê´€ì—†ì§€ë§Œ VariableSmmì€ Ring -2 ë‹¨ê³„ì—ì„œ ì‹¤í–‰ë˜ë¯€ë¡œ ê³µê²©ìê°€ ì•…ì˜ì ìœ¼ë¡œ ì¡°ì‘ëœ ì‹œìŠ¤í…œ ë³€ìˆ˜ë¥¼ í†µí•´ ctx->blockì— ì•…ì„± ì½”ë“œë¥¼ ì‹¬ì„ ìˆ˜ ìˆë‹¤ë©´, í•´ë‹¹ ì½”ë“œê°€ ê²€ì¦ ì—†ì´ ì‹¤í–‰ë  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— SMM Callout ì·¨ì•½ì ì´ ë°œìƒí•  ìˆ˜ ìˆë‹¤ê³  ìƒê°í•˜ì˜€ë‹¤.
<br>
&nbsp;í•˜ì§€ë§Œ ê²°ë¡ ë¶€í„° ë§í•˜ë©´ í•´ë‹¹ ë¶€ë¶„ì´ ì·¨ì•½ì ì´ ë˜ì§„ ì•Šì„ ê²ƒì´ë¼ ìƒê°í•œë‹¤.
> When the attribute EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS is set, but the EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS is not set (i.e. when the EFI_VARIABLE_AUTHENTICATION descriptor s used), then the* Data buffer shall begin with an instance of the authentication descriptor AuthInfo prior to the data payload and DataSize should reflect the data and descriptor size. The authentication descriptor is not part of the variable data and is not returned by the subsequent calls to GetVariable. The caller shall digest the Monotonic Count value and the associated data for the variable update using the SHA-256 1-way hash algorithm. The ensuing the 32-byte digest will be signed using the private key associated w/ the public 2048-bit RSA key PublicKey described in the EFI_CERT_BLOCK_RSA_2048_SHA256 structure.

[UEFI Specification 2.10 Variable Authentication](https://uefi.org/specs/UEFI/2.10/08_Services_Runtime_Services.html)
ìœ„ ê¸€ì€ UEFI.orgì˜ Variable Authentication ë¶€ë¶„ ë‚´ìš© ì¤‘ ì¼ë¶€ë¡œ, ê³µê°œ í‚¤ ë°©ì‹ì¸ RSA, ê·¸ë¦¬ê³  í•´ì‹œ(SHA)ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ëª…ì„¸í•˜ê³  ìˆë‹¤. ì¦‰ ë¹„ë°€ í‚¤ ë°©ì‹ì¸ GCMì€ í‘œì¤€ì´ ì•„ë‹Œ ê²ƒì´ë‹¤. ë”°ë¼ì„œ ì°¾ì•˜ë˜ ì½”ë“œëŠ” ì•„ë§ˆ ë§ì»¤ê°€ SHA ë° RSAë¥¼ ê°€ì ¸ì˜¤ê¸° ìœ„í•´ OpensslLib ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ê°€ì ¸ì˜¤ëŠ” ê³¼ì •ì—ì„œ ë”¸ë ¤ë“¤ì–´ì˜¨ ì½”ë“œê°€ ì•„ë‹ê¹Œ ìƒê°í•˜ê³  ìˆë‹¤.
<br>
_ì•„ë§ˆ ë‹¤ìŒìœ¼ë¡œëŠ” ì´ë²ˆ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì¡°ê¸ˆ ë” ë°œì „ì‹œì¼œ ë³´ê±°ë‚˜ SMM ì‹¤í–‰ ì¤‘ gBS(global Boot Service) ì‹¤í–‰ ì—¬ë¶€ë¥¼ ì°¾ëŠ” ë¡œì§ ìª½ìœ¼ë¡œ ê°€ë³¼ì§€ë¥¼ ê³ ë¯¼í•´ë³¼ ê²ƒ ê°™ë‹¤._