---
title: "UEFI DXE 바이너리 취약점 분석기 프로젝트_1"
tags: [UEFI, Ghidra]
math: true
date: 2025-12-31 11:00 +0800
toc: true
thumbnail: "/image/bios.png"
---
## UEFI란
UEFI(Unified Extensible Firmware Interface, 통일 확장 펌웨어 인터페이스)란 기존 BIOS를 대체하기 위해 나온 규격이다.  
기존 Legacy BIOS는 CPI 실행 과정에서 16비트 모드(키보드 탐색만 지원)에서만 실행이 될 수 있었다.   
이는 메모리 주소 공간이 1MB로 제한되므로 CPU의 속도가 아무리 빨라져도 부팅 초기화 단계에서 구식 CPU의 수준에서만 동작할 수 있었다.  
![제목](\image\bios.png){: width="40%" height="40%"}  
구형 BIOS의 모습이다. 마우스 등의 장치로는 불가능하고 오직 키보드로만 탐색할 수 있었다.<br>
또한 BIOS가 사용하는 MBR 방식은 주소를 32비트로 관리함에 따라 최대 2TB 용량의 저장 장치만 사용할 수 있었다. 이런 문제를 해결하기 위해 UEFI가 등장했다고 보면 될 것 같다.
내용은 이 [링크](https://bob-mcd-team.gitbook.io/uefi/introduction-uefi/2.uefi-introduction)를 통해 많이 공부하였다. 

## UEFI 부팅 순서
(BIOS의 부팅 순서는 따로 설명하지 않겠다.)  
![제목](\image\uefi_boot_pipeline.png){: width="40%" height="40%"}
UEFI 부팅 순서를 나타낸 그림이다.  

1\. SEC(Security) 단계  
시스템 전원이 켜지자마자 가장 먼저 실행되는 단계. CPU가 전원을 받아 reset vector에 처음으로 명령어를 받아온다. 이 과정은 16비트 real mode의 instruction을 실행하는데, 이 작업은 프로세서를 보호 모드로 전환한다. 또한 갓 컴퓨터에 전원이 들어온 상태이므로 메인 메모리가 아직 초기화되지 않았으므로 CPU의 L1/L2 캐시를 임시 RAM으로 사용해 C 코드를 실행할 준비를 하며, 그리고 초기 펌웨어 코드가 변조되지 않았는지 검증하는 Pre-Verifier 단계를 수행한다.

2\. PEI(Pre-EFI Initialization) 단계  
이 단계에서 메인 메모리를 포함한 칩셋들을 초기화한다.

3\. DXE(Driver Execution Enviroment) 단계  
**우리가 중점적으로 볼 부분이다.**
PEI 단계에서 메모리가 초기화되어 사용할 수 있는 상태가 되었으므로 본격적으로 드라이버들을 Load한다. 실행 파일은 PE32, PE32+(64비트) 파일이 사용된다. 이 단계에서 각 모듈들을 열거하고 실행하는 Dispatcher가 존재하는데, 각 모듈들은 USB, 그래픽, 네트워크, 파일 시스템 등 기능들을 불러오게 된다.  
_(*HOB(Hand-Off Block) : PEI에서 DXE로 넘어갈 때 전달되는 구조체로, 이 안에 메모리 유효 범위, 부팅 볼륨 등의 정보가 담겨있으므로 이 부분을 분석하는 것이 시작점이 되지 않을까... 싶다)_

4\. BDS(Boot Device Selection) 단계  
부팅 정책에 따라 GPT 디스크 및 EFI 시스템 파티션(OS 부트로더)을 찾는다. 이 때 윈도우라면 bootmgfw.efi, 리눅스라면 grub.efi 등 각 운영체제별 부트로더 정보들이 있고, 이를 찾아 메모리에 로드하는 단계가 된다. 우리가 컴퓨터를 켜서 BIOS 설정 환경으로 넘어가기 위해 F2나 Del키를 연타하게 되는데 이 설정 환경이 여기서 실행되게 된다.

5\. TSL(Transient System Load) 단계  
OS 부트로더는 이미 실행중이지만, 이 단계까지 아직 UEFI의 Boot Services를 이용할 수 있다. 부트로더가 최종적으로 커널 메모리에 올라가 실행 환경이 구축되었다면 ExitBootServices() 함수를 호출하여 제어권을 OS에 완벽히 넘기고 UEFI는 부트 프로세스를 종료한다.

6\. RT(Run Time) 단계  
여기부턴 OS가 완전히 컴퓨터의 제어권을 잡고 실행하게 된다. UEFI는 이 때 시스템 시간 가져오기, 시스템 리셋, 디바이스 드라이버 로드 등 일부 Runtime Service들만 사용하게 된다. 

7\. AL(After Life) 단계  
시스템이 종료되는 시점이다.
* * *
## 간단히 실제 DXE 살펴보기
제미나이와 함께 간단하게 DXE .efi 파일이 어떻게 되어있는지 살펴보았다.
사용 모델은 DELL XPS 15 9560의 UEFI를 [여기](https://www.dell.com/support/product-details/ko-kr/product/xps-15-9560-laptop/drivers)서 다운받았다.

다운을 받으면 .exe 형태의 파일이 다운받아진다. 이를 추출하기 위해 깃허브에 올라와있는 [추출기](https://github.com/vuquangtrong/Dell-PFS-BIOS-Assembler/tree/master)를 다운받아 실행하였다.
![제목](\image\after_extract.png){: width="40%" height="40%"}
추출이 완료되면 폴더가 하나 생기고 폴더 안에는 위 이미지와 같이 추출된 펌웨어들이 .bin의 형태로 저장되어 있는 것을 볼 수 있다.
이 중 "System BIOS with BIOS Guard v1.24.0.bin" 이란 파일이 분석 대상이라고 판단. 이 파일을 [UEFITool](https://github.com/LongSoft/UEFITool)을 통해 열어보았다.

![제목](\image\using_uefitool_first.png){: width="40%" height="40%"}
해당 파일을 UEFITool을 통해 열었을 때 위와 같은 화면이 나옴을 알 수 있었다.
앞으로 이 부분들을 우리가 분석해나가야 할 것들이 될 것이다.