---
title: "UEFI DXE 바이너리 취약점 분석기 프로젝트_4"
tags: [UEFI, Ghidra]
toc: true
math: true
date: 2026-01-22 11:00 +0800
thumbnail: "/image/image36.jpg"
---

## WSMT
&nbsp;중첩된 포인터에 따른 SMRAM 오염을 설명하기 전 WSMT에 대해 공부를 할 필요가 있었다. [WSMT](https://learn.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-uefi-wsmt)는 Windows SMM Security Mitigation Table의 줄임말로써 지난 시간에 이야기했던 ACPI 테이블 중 하나다. 이는 시스템 펌웨어가 SMM 소프트웨어에서 보안이 잘 지켜졌는지를 확인하도록 OS에게 이야기하는 역할이라고 볼 수 있다. 
![제목](/image/image36.jpg)
WSMT의 구조로, 총 3가지 Flag가 있는 것을 확인할 수 있고, 각 플래그들은
_FIXED_COMM_BUFFERS : OS가 지정한 고정 CommBuffer만 사용하는가_
_COMM_BUFFER_NESTED_PTR_PROTECTION : CommBuffer의 중첩 포인터까지 검증하는가_
_SYSTEM_RESOURCE_PROTECTION : 시스템 주요 설정들을 잘 보호하는가_
세 가지를 담고 있다.
&nbsp;여기서 큰 문제가 발생하는데, WSMT는 위 세가지 문제에 대해 "검증"을 하는 것이 아닌 각 제조사가 해당 플래그를 켰는지 "확인"만 한다. 즉 제조사들은 이를 준수하지 않았더라도 Flag를 True로 뒀다면 OS는 그것을 믿고 별도 검증 기능 없이 바로 해당 핸들러를 수행하게 된다. 

## SMRAM Corruption using Nested Pointer
&nbsp;중첩된 포인터를 이용한 SMRAM 오염은 CommBuffer를 통해 값을 받고, 또 CommBuffer에 값을 저장할 때 이중(또는 그 이상) 포인터를 사용하는 과정에서 생기는 문제를 의미한다. 아래 예제는 [CVE-2023-5058](https://www.binarly.io/advisories/brly-dva-2023-026) 사례로, 후지쯔 펌웨어, 또는 레노버 Yoga Slim 7 Pro에 들어간 UEFI에 발생한 취약점이다.
```C
EFI_STATUS __fastcall ChildSwSmiHandler(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        _QWORD *CommBuffer,
        UINTN *CommBufferSize)
{
    ...
    Ptr2 = (CommBuffer[22] + 8);
    for ( i = *Ptr2; i != Ptr2; i = *i )
    {
      i[24] = 0;           // unchecked write (SMRAM corruption)
      i[4] = 0;            // unchecked write (SMRAM corruption)
      i[6] = 0;            // unchecked write (SMRAM corruption)
    }
    ...
}
```
코드의 일부다. 위 코드를 보면 Ptr2에 CommBuffer가, 그리고 그 안에 있는 값들을 별도 검사 없이 사용하는 모습을 볼 수 있다. 물론 CommBuffer가 SMRAM에 침범하는지 검사가 이뤄졌을 것이고, 통과가 되어 CommBuffer를 사용했을 것이다. 하지만 만약 해커가 CommBuffer 내부 24, 4, 6번 등에 악의적인 Payload를 심었다면 해당 핸들러는 CommBuffer만 검사하고 내부 요소들은 검사하지 않았으므로 해당 Payload들이 SMM 권한을 얻은 채 실행될 것이다.