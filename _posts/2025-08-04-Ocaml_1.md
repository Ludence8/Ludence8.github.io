---
layout: post
title: "[PL, Ocaml] Ocaml 공부해보기_1"
tags: [PL, Ocaml]
math: true
date: 2025-08-04 22:00 +0900
categories:
    - Study
toc: true
---
최근 PL 분야에 대한 관심아 조금 생겨서 이 분야를 조금이나마 이해해보기 위해 Ocaml을 공부해보기로 했다.   
3학년 1학기에 있는 프로그래밍언어개론 이라는 과목에서 Ocaml을 알려주지만 해당 과목을 수강하지 않아 PL 분야 석사 과정을 밟고 있는 친구의 도움을 빌려서 공부해보기로 하였다...   
* * *
## Ocaml이란?
![제목](\assets\Ocaml_namu.png){: width="40%" height="40%"}   
나무위키에 나와있는 Ocaml에 대한 설명이다. 무작정 보면 이해하기 힘드므로 천천히 살펴보자.   
먼저 Ocaml은 ML 계열이라고 하는데 이는 Machine Learning의 ML이 아닌 Meta Language의 줄임말이다.   
Meta Language, 메타 언어란 쉽게 설명해 "언어를 설명하는 언어" 라고 설명할 수 있다.   
우리가 일상에서 쓰는 한국어, 또는 if(x > 0) then... 과 같은 프로그래밍 언어와 같은 이런 언어들을 설명하기 위한 언어라고 할 수 있다.   
예를 들어 위에 적은 if(x > 0) then... 이런 코드가 있을 때 이는 괄호 안 조건이 참일 경우 실행된다는 말을 담고 있다.   
이런 코드를 넘어 언어의 전체적인 논리 시스템을 표현하기 위해 만들어진 언어들이라고 볼 수 있다.   
   
또 그 다음으로 함수형 프로그래밍 언어라고 적혀있다.   
함수형 프로그래밍 언어는 말 그대로 "함수"를 통해 프로그램을 구성하는 언어라고 볼 수 있다.   
좀 더 쉽게 이야기해 언어를 전부 함수의 계산을 가지고 표현한다고 볼 수 있다.   
함수형 프로그래밍 언어는 "불변성"과 "순수성"을 원칙으로 만들어지는데, 불변성이란 메모리의 값을 변경할 수 없는 것을 뜻한다.   
예를 들어 f(x) = x + 2 라는 함수가 있을 때 f(3) = 5이고 이는 변하면 안되는 것이다.   
하지만 대입을 하여 여기서   
x = 3;   
x = x + 1;   
를 쓰게 되면 x의 값이 변하게 된다.   
이 때 함수형 프로그래밍 언어는 모든 인자를 함수로 처리하고, 이 함수들에 대입을 하게 되면 불변성을 해치므로 대입이 존재하지 않는다는 특징이 있다.   
다음으로 순수성(순수 함수)는 항상 같은 입력이면 같은 출력을 내고, 이 과정에서 부작용이 존재하지 않는 함수를 의미한다.   
예를 들어   
let add x y = x + y;
라는 함수가 있을 때 add 2 3을 호출하면 어디서든 항상 5라는 결과가 나올 것이다.   
이를 순수 함수라고 하고, 함수형 프로그래밍 언어는 이러한 요소들을 포함하는 언어라고 볼 수 있다.
또한 이 외에도 모든 변수 및 표현식 타입이 컴파일 시점에 결정되는 Strongly typed language, 타입 시스템이 변수 및 표현식의 타입을 추론하는 Type Inference 등의 특징을 가지고 있다.   

## Pattern Matching
Ocaml을 공부하며 가장 신기했던 기능이다.   
패턴 매칭이란 함수형 언어가 가지는 특징으로, 값의 구조를 전부 분해하여 조건에 따라 분기하는 방법이다.   
쉽게 생각하여 Case문이나 if-else문과 비슷한 문법이지만 훨씬 직관적이고 깔끔하게 조건을 나눌 수 있는 방법이다.   
쉽게 생각하여 피보나치 수열을 구현한다고 해보자.   
피보나치 수열을 구현하기 위해 필요한 조건으로   
1.Fibo(0) = 0   
2.Fibo(1)= 1   
3.fibo(n) = fibo(n - 1) + fibo(n - 2)   
이렇게 나눌 수 있는 것이다.   
이를 Ocaml로 나타내면   
```ocaml
let rec fib (n : int) : int = 
  match n with
  | i when i < 0 -> -1 (* 음수 처리 *)
  | 0 -> 0
  | 1 -> 1
  | n -> fib (n - 1) + fib (n - 2)
```
로 쉽고 직관적으로 나타낼 수 있다.   
또한 배열에 대한 Head, Tail문을 통해 직관적으로 많은 것들을 구현할 수 있는데, 예를 들어 리스트의 제일 마지막 리스트를 뽑아내기 위한 last라는 함수를 구현하면   
```ocaml
let rec last (lst : 'a list) : 'a =
  match lst with
  | h :: [] -> h
  | h :: t -> (last t)
```
와 같이 매우 간단하게 패턴 매칭과 재귀만 가지고도 표현할 수 있는 것이다.   
